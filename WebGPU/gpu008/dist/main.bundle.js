(()=>{"use strict";var e={306:function(e,t){var o=this&&this.__awaiter||function(e,t,o,n){return new(o||(o=Promise))((function(r,a){function i(e){try{c(n.next(e))}catch(e){a(e)}}function u(e){try{c(n.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(i,u)}c((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.CheckWebGPU=t.InitGPU=t.CreateGPUBuffer=void 0,t.CreateGPUBuffer=(e,t,o=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const n=e.createBuffer({size:t.byteLength,usage:o,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set(t),n.unmap(),n},t.InitGPU=()=>o(void 0,void 0,void 0,(function*(){var e;const o=t.CheckWebGPU();if(o.includes("Your current browser does not support WebGPU!"))throw console.log(o),"Your current browser does not support WebGPU!";const n=document.getElementById("canvas-webgpu"),r=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),a=yield null==r?void 0:r.requestDevice(),i=n.getContext("webgpu"),u=(window.devicePixelRatio,navigator.gpu.getPreferredCanvasFormat());return i.configure({device:a,format:u,alphaMode:"opaque"}),{device:a,canvas:n,format:u,context:i}})),t.CheckWebGPU=()=>{let e="Great, your current browser supports WebGPU!";navigator.gpu||(e='Your current browser does not support WebGPU! Make sure you are on a system \n        with WebGPU enabled. Currently, WebGPU is supported in  \n        <a href="https://www.google.com/chrome/canary/">Chrome canary</a>\n        with the flag "enable-unsafe-webgpu" enabled. See the \n        <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> \n        Implementation Status</a> page for more details.   \n        You can also use your regular Chrome to try a pre-release version of WebGPU via\n        <a href="https://developer.chrome.com/origintrials/#/view_trial/118219490218475521">Origin Trial</a>.                \n        ');const t=document.getElementById("canvas-webgpu");if(t){const o=document.getElementsByClassName("item2")[0];if(o){function n(){t.width=o.offsetWidth,t.height=o.offsetHeight}t.width=o.offsetWidth,t.height=o.offsetHeight,window.addEventListener("resize",n)}}return e}},890:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ShadersOld=t.Shaders=void 0,t.Shaders=()=>({vertex:"\n        struct Output {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) vColor : vec4<f32>,\n        };\n        @vertex\n        fn main(@location(0) pos: vec4<f32>, @location(1) color: vec4<f32>) -> Output {\n            var output: Output;\n            output.Position = pos;\n            output.vColor = color;\n            return output;\n        }",fragment:"\n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }"}),t.ShadersOld=()=>({vertex:"\n        [[location(0)]] var<in> position : vec4<f32>;\n        [[location(1)]] var<in> color : vec4<f32>;\n        [[builtin(position)]] var<out> Position : vec4<f32>;\n        [[location(0)]] var<out> vColor : vec4<f32>;\n\n        [[stage(vertex)]]\n        fn main() -> void {\n            Position = position;\n            vColor = color;\n            return;\n        }",fragment:"\n        [[location(0)]] var<in> vColor : vec4<f32>;\n        [[location(0)]] var<out> fragColor : vec4<f32>;\n\n        [[stage(fragment)]]\n        fn main() -> void {\n            fragColor = vColor;\n            return;\n        }"})},927:function(e,t,o){var n=this&&this.__awaiter||function(e,t,o,n){return new(o||(o=Promise))((function(r,a){function i(e){try{c(n.next(e))}catch(e){a(e)}}function u(e){try{c(n.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(i,u)}c((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=o(306),a=o(890);n(void 0,void 0,void 0,(function*(){const e=yield r.InitGPU(),t=e.device,o=new Float32Array([-.5,-.5,1,0,0,.5,-.5,0,1,0,-.5,.5,1,1,0,-.5,.5,1,1,0,.5,-.5,0,1,0,.5,.5,0,0,1]),n=r.CreateGPUBuffer(t,o),i=a.Shaders(),u=t.createRenderPipeline({layout:"auto",vertex:{module:t.createShaderModule({code:i.vertex}),entryPoint:"main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32x3",offset:8}]}]},fragment:{module:t.createShaderModule({code:i.fragment}),entryPoint:"main",targets:[{format:e.format}]},primitive:{topology:"triangle-list"}}),c=t.createCommandEncoder(),s=e.context.getCurrentTexture().createView(),f=c.beginRenderPass({colorAttachments:[{view:s,clearValue:{r:.5,g:.5,b:.8,a:1},loadOp:"clear",storeOp:"store"}]});f.setPipeline(u),f.setVertexBuffer(0,n),f.draw(6),f.end(),t.queue.submit([c.finish()])}))}},t={};!function o(n){var r=t[n];if(void 0!==r)return r.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,o),a.exports}(927)})();
//# sourceMappingURL=main.bundle.js.map